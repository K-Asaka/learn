▫️解説
●動作確認
fileコマンドを使い、バイナリのフォーマットを確認する。
32bit ELFバイナリなので、実行権限を付与

$ chmod u+x simultaneous

実行してみる
$ ./simultaneous

Usageが表示される。コマンドライン引数を12個取ると分かる。
試しに1-12の数字を入力

$ ./simultaneous 1 2 3 4 5 6 7 8 9 10 11 12

FLAGという文字列はあるが、肝心の中身が出てこない。

●ltraceによる解析
$ ltrace ./simultaneous 1 2 3 4 5 6 7 8 9 10 11 12

calloc()が呼ばれているのが分かる。
calloc()は第1引数に1つ分のメモリサイズ、第2引数に確保する個数を与え、その分メモリを確保し、0で初期化する。今回の場合第2引数が12なので、コマンドライン引数分メモリを確保していると推測。
次に、atoi()が12回呼ばれている。atoi()は文字列で著された値をint型の数値に変換する関数。
右側にあるatoi()の戻り値を見てみると、今回入力した1-12の値になっている。
コマンドライン引数として与えた12個の文字列を数値に変換している。
つまり、文字ではなく数字をコマンドライン引数に与える。
最後にexit()の引数。一般的に正常にプログラムが終了した際は終了ステータスを0に設定する。
したがって、終了ステータスが1である今回の実行は正常終了ではないため、与えたコマンドライン引数が間違っていると判断できる。

ここまでの解析から、12個の数値に変換できる正しい文字列をコマンドライン引数に与える必要があることがわかる。

●gdb-pedaによる解析
デバッガを用いて解析する。
$ gdb simultaneous
gdb-peda$ start 1 2 3 4 5 6 7 8 9 10 11 12

バイナリは通常大量のコードから成り立つ。Reversingでは重要な部分を見つけて、局所的に効率よく解析するのがポイントになる。関数の呼び出し前後や条件分岐、文字列が利用されているところなどに着目すると効率よく解析を進められる。
まずはcalloc()の実行後までniコマンドで進める。

gdb-peda$ disassemble main
で確認できる
0x080485b5 <main+32>: call 0x80483e0 <calloc@plt>
0x080485ba <main+37>: add esp,0x10

この時のeaxの値はcalloc関数の戻り値である確保されたメモリの先頭アドレスとなっている。
次のmovではeaxを[ebp-0x24]に格納している。そのため、main()内で、[ebp-0x24]を参照することがあれば、確保したメモリの先頭アドレスを利用しようとしていると言える。

ltraceの結果からコマンドライン引数がatoi()によって数値に変換されていることは知っているので、最初のatoi()の実行後までniコマンドで進める。その後、nearpc 10を入力。nearpcは現在のeipを中心にして逆アセンブル結果を表示する。

gdb-peda$ nearpc 10

この時のeaxの値は、atoi関数の戻り値となっている。実際に以下のようにしてeaxの値を見ると、実際にコマンドライン引数の最初の1が格納されている。

gdb-peda$ i r eax
eax	0x1	0x1

ltraceの結果からatoi()が12回呼ばれているのを確認した。こういったループ処理はcmp命令とjmp系の命令を組み合わせることで実現する。
<main+149>のcmp命令で、eaxと[ebp-0x20]を比較した後、jl命令を実行して表示されているコード部分よりも前の<main+92>にジャンプしようとしている。このeaxは<main+146>が示すように[ebp-0x2c]から移動されてきた値。さらにその直前のadd命令で1を加算されている。
そこで、cmp命令では、eaxとどんな値を比較しているのか確かめるために[ebp-0x20]の値を表示してみる。

gdb-peda$ x/wd $ebp-0x20
0xffffd418:	12

eaxと12を比較していることがわかる。12と比較してeaxの方が小さかったら前にジャンプし、atoi()や[ebp-0x2c]に1を加算する処理が続き、eaxが12になった際にはジャンプせずに、次の命令に処理が進むことになる。したがって、ここで12回のループ処理を実行していると言える。ここのループを毎回実行していても無駄なので、<main+154>にブレークポイントを張って、cコマンドでループ後まで飛ばせるようにしておくと便利。

gdb-peda$ b *main+154
gdb-peda$ c

cコマンドを入力後の逆アセンブル結果を確認する。
この結果から、<main+160>でcheck()が呼ばれていることが分かる。
この関数の引数は直前でpushしている[ebp-0x24]なので、calloc()の戻り値である確保したメモリの先頭アドレスをcheck()に渡していることになる。
また、check()の戻り値は<main+168>で[ebp-0x1c]に格納される。
[ebp-0x1c]はmain()の後ろのほうでexit()の引数になっている。
終了ステータスとして0を引数に渡すためには、check関数の戻り値を0にする必要がある。

gdb-peda$ x/2wi main+255

・check()の解析
check()の全体構造を把握するためdisasコマンドでcheck()全体を逆アセンブルする。

gdb-peda$ disas check

<check+6>で[ebp-0x4]に0を格納している。
その後、<check+57>にジャンプ。<check+57>では、cmp命令で[ebp-0x4]と11を比較して、[ebp-0x4]が11以下ならば<check+15>にジャンプするjle命令が実行される。さらにcmp命令の上には[ebp-0x4]に1を加算する処理がある。したがって、これらの処理は[ebp-0x4]をカウンタとした12回のループ処理をしていることがわかる。
jle命令でジャンプした<check+15>からの命令では、[ebp-0x4]と[ebp+0x8]を引数にsum()を呼ぼうとしている。[ebp-0x4]はループ毎に1ずつ増加する値で、[ebp+8]はcheck()の引数として渡された確保したメモリの先頭のアドレス。ひとまずsum()の中は追わずにsum()後の処理を追ってみる。
sum()の戻り値は<check+30>でedxに移される。次にsum()の戻り値が格納されていたeaxは、カウンタである[ebp-0x4]で上書きされた後、[eax*4+0x8048980]で更新される。
eaxは0-11に増加していく値なので、[eax*4+0x8048980]で参照される値もループ毎に変化していく。
今回は12回ループがあるため、アドレス0x8048980から4byteずつ12個分のメモリに格納された値が参照される。

実際に0x8048980に格納されている値を見てみる。

gdb-peda$ x/12wd 0x8048980

結果から変数名としてbが与えられていることがわかる。
続く<check+57>のcmp命令では、sum()の戻り値であるedxと上記の値が格納されたeaxを比較する
。もし等しかったらje命令で<check+53>に戻るが、そうで無かったらeaxに1を格納してから関数を抜ける<check+68>にジャンプする。
もし12回のループで全てが等しかったら<check+61>のjle命令で飛ばずにeaxに0を格納して関数が終了する。したがって、check()の戻り値を0にするためには、12回のループでsum()の戻り値がすべて参照される上記の値と等しくなるようにする必要がある。

・sum()の解析
次はsum()を解析し、どのような処理が行われて戻り値が決まっているかを確認する。check()と同様にdisasコマンドを使って全体を逆アセンブルする。

gdb-peda$ disas sum

まず<sum+6>からのmov命令では、[ebp-0x4]と[ebp-0x8]に0を格納している。
その後<sum+73>にジャンプ。<sum+73>では、cmp命令で[ebp-0x4]と0xbを比較して、[ebp-0x4]が11以下だった場合<sum+22>にジャンプするようになっている。また、<sum+69>ではadd命令で1加算されていることから、[ebp-0x4]をカウンタとした12回のループ処理が存在することがわかる。

1回目のループ内の<sum+22>からの処理を追ってみる。<sum+22>では、0で初期化された[ebp-0x4]をeaxに格納している。その後、[eax*4+0x0]で4倍にしてedxに格納している。

<sum+32>では、sum関数の第1引数であるメモリの先頭アドレスをeaxに格納して、先ほどのedxを加算。1回目のループでは0を加算することになるが、2回目は[ebp-0x4]が1であるため4を足すことになる。その後、eaxが指す値をecxに格納している。つまりコマンドライン引数の値をecxに格納する一連の処理になる。
確かめるために<sum+39>にブレークポイントを張って、cコマンドで処理を続行させてみる。そうすると、eaxは確保されたメモリの先頭アドレスを指しており、ecxにはそのアドレスが指す値が格納されていることがわかる。

gdb-peda$ b *sum+39
gdb-peda$ c
gdb-peda$ i r eax ecx

次に<sum+39>からの処理を追う。[ebp+0xc]はsum()の第2引数で、check()のループ内で0-11に変化する値。これをedxに格納後、eaxにも格納する。<sum+44>では、add命令で同じeaxを足している。つまり2倍している処理を行なっている。その後add命令でeaxにedxを格納している。この時点で同じ値を3回足していることになるので、3倍していることになる。さらにshl命令で2bitシフトしていることから4倍していることになるので、結果としてeaxには[ebp+0xc]に格納されていた値を12倍した値が格納されていることになる。

<sum+51>で[ebp-0x4]をedxに移動後、eaxに加算する。最初のループではeaxが0だが、check()が2回目のループの場合、12を加算することになる。そして次のmov命令では、[eax*4+0x8048740]が指す値をeaxに格納する。外側のループであるcheck()と内側のループであるsum()を考慮すると、この参照される値は12個ずつずれて、12回参照されることになるので、合計で144個の値が格納されていることになる。
実際に0x8048740に格納されている値を見る。

gdb-peda$ x/144wd 0x8048740

この結果から、変数名としてcofficientsが与えられていることもわかる。
続く<sum+63>のimul命令では、参照される上記の値が格納されたeaxとコマンドライン引数の値が格納されたecxの乗算をする。そして、乗算結果であるeaxを次のadd命令で0初期化した[ebp-0x8]に加算する。その次の命令たちはループ処理の命令たちなので、ここまでの処理が12回繰り返されることになる。つまり、cofficientsの値とコマンドライン引数の値の乗算結果の合計が[ebp-0x8]に格納される。そして<sum+77>のjle命令でジャンプしない場合は、<sum+79>のmov命令でeaxに[ebp-0x8]が格納され、戻り値になる。

これらの解析結果から、sum()はcofficientsの値とコマンドライン引数の値の乗算結果の合計を返す関数だとわかる。check()の解析結果も踏まえると12回のループ全てでcofficientsの12個の値とコマンドライン引数の乗算結果の合計がbの値と等しくなる必要があるということがわかる。
この解析結果を数学的に考えると、未知数が12個存在する連立方程式となる。

●連立方程式を解く
連立方程式を解く際に、未知数が2、3個であれば手で解くこともできるが、12個となると大変。z3というツールを用いて方程式を解く。
z3はMicrosoft Researchによって開発された充足問題を解くことができるツール。様々な言語のバインディングが存在する。その中でも今回は、Python2系からz3を利用してみる。
また、z3はGitHub上で公開されているので、以下のURLからGitHubにアクセスし、cloneしてビルド・インストールすることができる。

https://github.com/Z3Prover/z3

まずはじめにz3のサンプルプログラムを示す。
これは、x^2-6x+9=0という二次方程式を条件にすることで、これを満たすxを求めることができる。

from z3 import *
x = Int("x") # z3で扱う変数の宣言
s = Solver()
s.add(x ** x - 6 * x + 9 == 0) # 条件を追加
r = s.check()
if r == sat:
    m = s.model()
        print m[x].as_long() # 答えの表示

本問題においては12個の解が存在するので、上記のように変数を12個作っても良いが、z3の配列を用いると次のように表現することができる。また、要素へのアクセスは普通のリストと同じようにインデックスでアクセスすることができる。

x = IntVector("x", 12)

実際に12個の条件式を追加して作成したプログラム。

from z3 import *
x = IntVector("x", 12)
s = Solver()
s.add(x[0] * -72 + x[1] * -74 + x[2] * 91 + x[3] * 59 + x[4] * 53 \
    + x[5] * -95 + x[6] * -32 + x[7] * -39 + x[8] * 93 + x[9] * 76 \
    + x[10] * -31 + x[11] * 22 == 4885)
s.add(x[0] * 78 + x[1] * -84 + x[2] * -96 + x[3] * 69 + x[4] * -21 \
    + x[5] * -72 + x[6] * 89 + x[7] * -26 + x[8] * 21 + x[9] * 65 \
    + x[10] * 3 + x[11] * 49 == 10656)
s.add(x[0] * -46 + x[1] * 11 + x[2] * -39 + x[3] * 54 + x[4] * 57 \
    + x[5] * -14 + x[6] * 59 + x[7] * -10 + x[8] * 77 + x[9] * -34 \
    + x[10] * 0 + x[11] * 99 == 14249)
s.add(x[0] * 27 + x[1] * 4 + x[2] * 52 + x[3] * 23 + x[4] * -1 \
    + x[5] * 43 + x[6] * -41 + x[7] * 13 + x[8] * 9 + x[9] * -70 \
    + x[10] * -16 + x[11] * 91 == 7244)
s.add(x[0] * 60 + x[1] * -92 + x[2] * 84 + x[3] * 58 + x[4] * -8 \
    + x[5] * -6 + x[6] * 91 + x[7] * 8 + x[8] * -30 + x[9] * -11 \
    + x[10] * -5 + x[11] * -96 == 17152)
s.add(x[0] * -91 + x[1] * -16 + x[2] * -96 + x[3] * 51 + x[4] * -56 \
    + x[5] * -85 + x[6] * -52 + x[7] * 46 + x[8] * -78 + x[9] * 87 \
    + x[10] * 96 + x[11] * -83 == -22439)
s.add(x[0] * -32 + x[1] * -80 + x[2] * -80 + x[3] * 54 + x[4] * -28 \
    + x[5] * -85 + x[6] * -38 + x[7] * -75 + x[8] * 5 + x[9] * 32 \
    + x[10] * -80 + x[11] * -72 == -41829)
s.add(x[0] * 5 + x[1] * -18 + x[2] * 6 + x[3] * 74 + x[4] * -9 \
    + x[5] * -64 + x[6] * 30 + x[7] * -44 + x[8] * -26 + x[9] * -6 \
    + x[10] * -22 + x[11] * 13 == -7222)
s.add(x[0] * 30 + x[1] * 61 + x[2] * -100 + x[3] * 63 + x[4] * -19 \
    + x[5] * -92 + x[6] * 68 + x[7] * -38 + x[8] * -11 + x[9] * -96 \
    + x[10] * 44 + x[11] * -50 == -12530)
s.add(x[0] * 59 + x[1] * 4 + x[2] * 99 + x[3] * -62 + x[4] * -34 \
    + x[5] * -89 + x[6] * -52 + x[7] * 87 + x[8] * 22 + x[9] * 38 \
    + x[10] * 86 + x[11] * 15 == 18797)
s.add(x[0] * -75 + x[1] * -92 + x[2] * -21 + x[3] * 62 + x[4] * -77 \
    + x[5] * -31 + x[6] * -10 + x[7] * 90 + x[8] * 83 + x[9] * 89 \
    + x[10] * 66 + x[11] * -17 == 13201)
s.add(x[0] * -5 + x[1] * 23 + x[2] * -29 + x[3] * 16 + x[4] * 25 \
    + x[5] * 50 + x[6] * 95 + x[7] * 65 + x[8] * -57 + x[9] * 35 \
    + x[10] * 4 + x[11] * 22 == 22623)
r = s.check()
if r == sat:
    m = s.model()
    for i in range(12):
        print m[x[i]].as_long(),

このプログラムを実行すると以下の結果が得られる。

122 51 95 98 101 103 105 110 110 101 114 33


●連立方程式の解の入力
連立方程式を解いて得られた値を実際にコマンドライン引数として入力してみる。

$ ./simultaneous 122 51 95 98 101 103 105 110 110 101 114 33

FLAGが出力される。これが正しいか判断するために、ltraceコマンドを利用して終了ステータスを見る。

$ ltrace ./simultaneous 122 51 95 98 101 103 105 110 110 101 114 33

この結果からstatusが0で正常に終了しているため、フラグが正しいことがわかる。


番外編：Numpyを用いた解法
行列演算を用いた数学的なアプローチで連立方程式を解く。

一般的に連立方程式は解ベクトルx、係数行列A、定数ベクトルbとすると以下のように表現できる。

Ax = b

この時、係数行列Aに逆行列A^-1が存在する場合、両辺に左からかけることで以下の等式が成り立つ。(ただしEは単位行列)

A^-1 Ax = A^-1 b
Ex = A^-1 b
x = A^-1 b

上記の式より、A^-1とbの乗算結果が解ベクトルxになることがわかる。
Pythonにおいて行列演算などを行う際には、機械学習や数値計算の分野でデファクトスタンダードになっているNumpy(http://www.numpy.org/)ライブラリが便利。
Numpyを用いて実装すると以下の通り。

import numpy as np
A = np.array([
  [-72,-74,91,59,53,-95,-32,-39,93,76,-31,22],
  [78,-84,-96,69,-21,-72,89,-26,21,65,3,49],
  [-46,11,-39,54,57,-14,59,-10,77,-34,0,99],
  [27,4,52,23,-1,43,-41,13,9,-70,-16,91],
  [60,-92,84,58,-8,-6,91,8,-30,-11,-5,-96],
  [-91,-16,-96,51,-56,-85,-52,46,-78,87,96,-83],
  [-32,-80,-80,54,-28,-85,-38,-75,5,32,-80,-72],
  [5,-18,6,74,-9,-64,30,-44,-26,-6,-22,13],
  [30,61,-100,63,-19,-92,68,-38,-11,-96,44,-50],
  [59,4,99,-62,-34,-89,-52,87,22,38,86,15],
  [-75,-92,-21,62,-77,-31,-10,90,83,89,66,-17],
  [-5,23,-29,16,25,50,95,65,-57,35,4,22]
])
b = np.array([[
    4885,10656,14249,7244,17152,-22439,
    -41829,-7222,-12530,18797,13201,22623
    ]]).reshape(12, 1)

print np.linalg.inv(A).dot(b)

