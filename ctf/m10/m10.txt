Login Me!


問題
Login Me!
http://192.168.1.151/index.php

問題ファイル
https://book.mynavi.jp/files/user/support/9784839962135/mondai10.zip


まずは指示のURLにアクセスすると、ログイン画面が表示される。
アカウント情報はどこにも記載されておらず、登録フォームもない。
ひとまず、robots.txtや.gitなどを漁ってみる。
ログインフォームがあって、.gitやrobots.txtが無ければ、素直にログインフォームを攻めるべき。

ログインを目指す場合、以下のような手法が浮かぶ。
・ID/PWの推測(問題文や、.gitのコード等から推測する)
・ログイン済みのセッションを奪う(XSS、セッション固定化など)
・SQL Injectionでログイン
・ディレクトリトラバーサルでID/PWで関連しそうな情報をつかむ


ID/PWの推測
既に、.git等が無いことは確認している。また、問題文にもそれらしいヒントはない。
何かの脆弱性と組み合わせてサーバ上にあるファイルが漁れれば、その情報を基にログインできるかもしれないが、現状この方法は難しそうである。ID/PWファイル(ログインID/パスワードファイル、例えば/etc/shadow等)をとれそうであればとる事を目標に入れつつ、別の脆弱性を探す。ただ多くの場合これらの脆弱性はログイン後なので、忘れてしまっても大丈夫。


ログイン済みのセッションを奪う
このパターンは様々なCTFでも出題されている。真っ先に考える王道手法となっている。
まず適当なID/PWでログインを試みる。

ID欄に入力したものがログイン画面に出力されていることがわかる。
そこで次に、<>"等クロスサイトスクリプティングで使えそうな文字種を送り、そのソースを閲覧してみる。

これは正しくエスケープされている。クロスサイトスクリプティングは難しそうだが、目に見えていない箇所でスクリプトを動作させてセッションを奪う可能性もある。
ID/PWやUser-Agentを操作して、ログイン履歴ページでの蓄積型クロスサイトスクリプティングを利用するパターンなど。この手のパターンの場合、そのページへの誘導がある。例えばログイン失敗時の画面上に過去の失敗回数やUser-Agentに関する情報が出力されているなど。
しかし、今回はそれらしきものが見当たらない。
今後の挙動の中でログを書き出していそうな何かを見つけた場合は試してみる事を忘れずに、次の可能性を考える。


SQL Injectionでログインする
クロスサイトスクリプティングと合わせてWeb問題での王道手法となっている。
CTFに関係ない書籍でも、SQL Injectionの典型例として認証回避のパターンが紹介されている。
ログイン画面にSQL Injectionがある場合、ID/PWともに文字列であるため、文字列リテラルを終わらせてから任意の構文を書くことになる。そのため、文字列リテラルを終わらせることができるか判断する必要がある。ただし今回はho'||'geのような文字列連結を利用した際の挙動の比較は行えない。なぜなら、正しいID/PWを知らないため。文字列連結が成功していようといまいと、画面上にはIDが存在しないという結果しか出力されず、挙動の差がない。そこでっこでは、いきなり以下のような文字列を送る。

hoge' OR 1=1; --

これにより、SQL文が以下のような構造だった時に挙動に変化が現れることが期待できる。
ここではまず、SQL Injectionが可能かの判定を優先しているため、MySQL、PostgreSQL、SQLiteで使用可能な--のコメント形式を使っている。ここで重要なのは末尾の半角スペースで、これがないとMySQLの場合はエラーとなってしまう。

SELECT * FROM users WHERE id = '[ここにPOSTされたID]';

細かいテーブル名やSELECTされているカラム名などは不明だが、少なくともログインという処理の特性上、WHERE句内でidと比較されている可能性が高い。
また、実際のWebアプリではあまりこういった書き方はしないが、CTFのため以下のようなSQL文であることもあり得る。

SELECT * FROM users WHERE id = '[ここにPOSTされたID]' AND password = '[ここにPOSTされたPW]';

この場合は認証処理をバイパスできるため、追加操作なしでログインすることが可能。
先の文字列を送った結果、今までと比べて挙動が変化する。
ということは、おそらくこの手法が有効である可能性が高い。ここからは、SQL Injectionに絞って見ていく。なお、下記のようなSQL文だった場合は上記文字列を送っても挙動が変わらない場合がある。

SELECT * FROM users WHERE (id = '[ここにPOSTされたID]') AND (password = '[ここにPOSTされたPW]');

このような場合は通常、SQLのエラーであることを示すメッセージや、通常のログイン失敗時と異なるメッセージが出力されSQL文のミスである事を誘導してくれるはずだが、そういったものが無くても、1、2個のカッコがついていることを考慮するとよい。
具体的には、以下のようなパラメータの送信を試みる。

hoge')) OR 1=1; --


SQL Injection
おそらくSQL Injectionが可能だろうとわかったところで、先の検証で出てきたエラーを見てみる。そこには、adam is Not Admin Userと書かれている。おそらくログインには成功したものの、ログインしたユーザに権限がなかったのだろう。
' OR 1=1の場合、大概はヒットした最初のレコードがプログラムに渡される。
そのため、テーブルの一番最初のレコードに記録されているユーザには権限が無かったのだろう。ログインには成功したものの、ユーザに権限がない。となれば、ログインできる権限を持ったユーザを探し出す、というのが次の方針になる。
この問題では上記の思考を促すエラーが出力されているため、自然にDBの中身を漁る方向への誘導があるが、それが無く、すんなりとログインできて話が進む場合もある。その場合であっても、その後の問題へ使える情報があるかもしれない。できればデータベースの中を一通り見ておくよい。


SQL文の把握
SQL Injectionで何かを探す際にまずやることは、SQL文の把握とDBの種類の推定。
まずはInjectionできたSQL文の大雑把な全体像を把握する。
以下のように、UNION SELECTのカラム数を変えて挙動が変化するか確認する。
先のSQL文では、ログインIDとパスワードと権限を取得しているであろうと推測できるため、カラム数は3からスタートさせる。


hoge' UNION SELECT 1, 2, 3; --


hoge' UNION SELECT 1, 2, 3, 4; --

ここで挙動が変わる。今回は2、3回で変わったため試した方が早かったが、何度か試してもダメだった場合は以下のようなORDER BYを使った推定を試みた方が効率的な場合が多い。


hoge' OR 1=1 ORDER BY 10; --


これを行うと、10以上のカラム数であればログインに成功し、10未満のカラム数であれば失敗する。これに成功したら次はその倍の20で、失敗したらその半分の5で、のように数値を変えて試していくと、徐々にカラム数が絞り込める。


テーブルの構造を把握
続いて、DBのテーブルとカラムの把握。
カラム名がわからなければ何を指定すれば良いのかわからない。そもそもどんなテーブルがあるのかが分からなければSELECT文は書けない。というわけで、テーブル一覧を取得する。
テーブル名を調べるためにはDBの種類を把握しなければならない。
CTFで多く使われているのは先述のMySQL、PostgreSQL、SQLite。とりあえずこれらを優先して確認してみる。
挙動が変わった際のエラーメッセージを読むと、2を指定した箇所が画面上に出力されるとわかるため、そこをテーブル名にして以下のようなパラメータを送る。

hoge' UNION SELECT 1, group_concat(table_name), 3, 4 FROM INFORMATION_SCHEMA.tables; --

成功する。これで、テーブル名が同時に取得できる。
狙いはログインのため、ユーザ情報を格納していそうなテーブルを探す。すると、usersという露骨に怪しいテーブルが見つかる。続いて、このusersテーブルのカラム名を取得してみる。

hoge' UNION SELECT 1,group_concat(column_name), 3, 4 FROM INFORMATION_SCHEMA.columns WHERE table_name = 'users'; --

これでテーブル名とカラム名が揃う。


アカウント情報を取得する
ログインできる権限を持ったユーザを探し出すという当初の目標まであと少し。
先の試行で、このDBにはusersテーブルがあり、id、loginid、password、auth_bitというカラムがある事を突き止めた。おそらく、auth_bitというのが権限だろう。
この権限が他のユーザと異なっているユーザでログインすれば、おそらく権限のあるユーザとしてログインできるはず。ユーザ名さえつかめてしまえば' OR 1=1; --で認証をバイパスできるのだが、その後の処理に悪影響を及ぼさないためにもpasswordもセットで取得し、正しいIDと正しいPasswordでログインを試みることを目標とする。
そのために、以下のパラメータを送信する。

hoge' UNION SELECT 1,group_concat(concat(loginid, '<>', password, '<>', auth_bit), '<SEP>'), 3, 4 FROM users; --

この結果から、一人だけauth_bitの値が異なる"seccon"というユーザが権限を持っている可能性が高く、そのパスワードは"SECCON_4b"であると分かる。


ログイン
ここまでの情報を利用し、ID:seccon PW:SECCON_4bでログインしてみる。
Read Meという文字と、PHPINFOの画面が出る。


意図を読む
PHPINFOにはその昔XSSの脆弱性があり、それを使って何かするという方向性も考えられなくもないが、その場合はターゲットとなるユーザが必要になる。
加えてターゲットに罠を踏ませる方法も考えなければならないが、このサイトにはトラップとなりそうな箇所は見つからない。また、Read Meとはどういう意味か。
手詰まりになった時は、基本的に今まで試してきた道に情報があることが多い。
SQL Injectionで、何か見落とした情報が無いか考えてみる。


MySQLの特殊な関数
テーブル一覧を見る限り、めぼしい情報はなかった。そして「Read Me」の文字列。
これは、表示しているPHPファイルindex.phpのコードを読めという事。
MySQLには任意のファイルを読むload_fileという関数が備わっている。SQL Injectionを利用してサーバ上の任意のファイルを読める。
読む対象のファイルが定まっていて、MySQLでのInjectionが可能であれば、この手法を疑う。
対象が定まっていなくとも、この関数は、FILEの読み書きを許可する設定をした上で、FILE権限を意図的に与えたユーザまたはrootでログインしていなければ有効にはならないため、SQL Injectionの過程でこの条件を満たしていそうな雰囲気であれば、試してみる価値はある。
ただし、読み書きできる範囲が制限されている可能性もあり、読むべき対象が明確な場合の1つの手法として覚えておく。

ユーザ名を取得してみる。

hoge' UNION SELECT 1,CURRENT_USER( ),3,4; --

これでroot@localhostというユーザ名が確認できる。
次にPHPファイルの場所を探す。
典型的な置き場所は以下の通り。

/var/www/html/index.php
/etc/httpd/conf/httpd.conf
/etc/apache2/apache2.conf
/usr/share/nginx/html/index.php
/etc/nginx/nginx.conf

上2つはApacheの場合に見るべき典型例、下2つはnginxの場合に見るべき典型例。
各confファイルは、ここにDOCUMENT_ROOTの設定が記載されているため、これが読めれば概ねどこでscriptが動いているか特定できる。しかし、今回はこれらのパスは読めない。

もう一度PHPINFOを見てみる。
_SERVER["SCRIPT_FILENAME"]という項目に、スクリプトまでの絶対パスが書いてある。


hoge' UNION SELECT 1,load_file('/usr/local/sqli/pub/index.php'),3,4; --


これで以下のFLAGが取れる


FLAG_{EasySQLiForBeginners}


