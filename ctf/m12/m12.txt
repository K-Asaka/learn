Amazing Language

問題

とある経路で入手したこの2つのファイル(mondai12.zip)、何やら重要な情報が隠されている。見つけ出して欲しい。

https://book.mynavi.jp/support/pc/ctf4b/mondai12.zip


ダウンロードしたzipファイルを展開すると2つの画像ファイルが含まれている。
一見するとどちらも普通の画像。

CTFでは問題文や問題ファイル自体にヒントが含まれている場合が多い。
「隠された情報を見つけ出して欲しい」との記載から、この「隠された情報」がFLAGであると推測できる。

この問題のジャンルはWebとされているが、サーバ情報は提示されていない。あるのは画像ファイル2つだが、この問題のジャンルはForensics等のファイル解析系のものではなく、あくまでWeb。つまり、解き進めていく過程で、何らかの形でWebに関わる要素が出てくるという予想ができる。

問題ファイルに着目してみると、sample.pngとproblem.pngとある。
problem.pngが今回どうにかしなければならないファイルで、その足がかりとしてsample.pngを利用することができそうである。


fileコマンドでファイル種別を確認する
CTFで実態のよくわからない画像ファイルが与えられたら、試しておきたい手順がいくつかある。
今回与えられた画像ファイルは、本当に画像ファイルなのか。巧妙に偽装された画像ファイル以外の何か別のファイルではないか確認するために、fileコマンドでファイル種別を確認する。

ctf@ctf:~/ctf/m12/web400$ file *
problem.png: PNG image data, 59 x 58, 8-bit colormap, non-interlaced
sample.png:  PNG image data, 291 x 290, 8-bit colormap, non-interlaced

本当にPNG形式の画像ファイルのようである。


foremostでファイルの中に何か隠されていないか確認する
ForensicsやSteganographyジャンルの問題では、ファイルの中に別のファイルを隠すといった手法が用いられることがある。そういったファイルを抽出するツールは多数あるが、ここではforemostというツールを使って、今回の問題ファイルの中に別のファイルが隠されていないか確認してみる。

ctf@ctf:~/ctf/m12/web400$ foremost *
Processing: problem.png
|*|
Processing: sample.png
|*|

何も隠されていないことがわかる。
なにか別のファイルが隠されていた場合は、outputディレクトリに検出されたファイルが格納される。


思いつく手順は試してみたが新しいヒントは得られなかった。
視点を変えて取り組んでみる。
今回与えられた画像ファイルは、赤と黒だけで構成された比較的特徴的な画像。
何に使われる画像ファイルなのかわからず、類似の画像等からなにかヒントが得られないか確認してみる。


Google画像検索を使い、Web上から今回与えられた画像に関する情報を洗い出してみる。
ファイル名もヒントになるかもしれないため、まずはsample.pngで検索してみる。

・JavaScriptをPNGに圧縮する
http://yomotsu.net/blog/2015/03/01/js2png.html

興味深い記事が見つかる。

JavaScriptのソースコードを色情報に変換し、PNGファイルにすることが可能で、自己解凍機能を持たせてそのままJavaScriptとして実行させることもできるという内容。
自己解凍機能を持たせるために、PNGファイルの中にHTMLを埋め込むといった工夫をする。

今回与えられていたsample.pngはjQuery-2.1.3.min.jsを変換したもののようである。
このサンプルは、この記事に辿り着くためのヒントだった模様。
ここまでの情報で、残るもう一つのproblem.pngもJavaScriptのソースコードをPNGに変換したものである可能性が高い。元のソースコードにFLAGそのもの、あるいはFLAGに繋がる情報が含まれているとみてよい。


problem.pngが変換ツールによって変換されたJavaScriptのソースコードなのかを確認していく。もし自己解凍機能を備えたPNGファイルであればファイル内にHTMLタグが含まれている。PNGファイルはバイナリファイルのため、本来ならばバイナリエディタで確認するところだが、catコマンドで確認することもできる。HTMLタグを構成する文字は印字可能文字であるので、catコマンドでもきちんと表示されるはず。


<canvas id=c><img onload=for(w=c.width=59,h=c.height=58,a=c.getContext('2d'),a.drawImage(this,p=0,0),e='',d=a.getImageData(0,0,w,h).data;t=d[p+=4];)e+=
String.fromCharCode(t);(1,eval)(e) src=#>

それらしいHTMLタグが含まれているのがわかる。
画像ファイルの正体が判明した。次はWebブラウザで実際に実行してみる。

今回の問題ファイルをJavaScriptとして実行するためには、当該ファイルをHTMLとしてWebブラウザに読み込ませる必要がある。HTMLとして読み込ませるための一番シンプルな方法は、拡張子の書き換え。problem.pngをproblem.png.htmlとする。

画像ファイルを開いた時点で元のJavaScriptコードが実行されるはずだが、画面上にFLAGらしき文字列は表示されていない。実行するだけでは不十分のようで、もう少しこのファイルを調べてみる必要がある。

ブラウザに付属している開発者ツールを使い、ソースコードを確認する。
インスペクタでHTMLソースを整形した状態で表示して確認するとわかりやすい。
今回の問題ファイルではcanvasタグに画像ファイル自身を読み込んで、色情報を読み取って実行する、という自己解凍方式を取っているため、インスペクタに表示されているcanvasタグ左の三角形をクリックしてみる。
imgタグのonload属性に自己解凍のためのJavaScriptコードが記述されている。

色情報から一文字ずつ元のソースコードを復元して、最後にeval関数を呼び出して、元のソースコードを実行する、といったコード。コード末尾の(1,eval)(e)がeval関数を呼び出す箇所。eval関数の引数として指定されるのは元のソースコードと推測される。引数eの中身を見れば元のソースコードがわかる。

Firefoxの開発者ツールでは、JavaScriptコンソールというものが提供されている。簡単にJavaScriptのコードを実行することができる。
これを使い、eval関数の引数の中身を確認してみる。

eval関数の引数として指定されている変数eはグローバル変数なので、コンソールに単にeと打てば中身が表示される。
ソースコードにたどり着けると思ったら、わけのわからない文字列が並ぶ。

JavaScriptのeval関数で実行できている以上、このわけのわからない文字列はあくまでJavaScriptのコード。このような形でソースコードを人間が読みにくい形にすることを難読化と呼ぶ。難読化されたJavaScriptのソースコードの復元方法は大きく分けて2つある。

1つはFunctionオブジェクトのコンストラクタに難読化した文字列を渡して作成した関数オブジェクトを実行するもの、もう一つはeval関数等に難読化した文字列を渡して実行させるもの。


1つめはeval等の引数として指定された文字列をコードとして実行する性質のある関数を利用したもの。一見意味不明な文字列である難読化されたJavaScriptコードも、実行する過程で文字列に変換されていく。最終的に変換された文字列をeval等の関数に渡すことで実行することになるため、今回の問題でPNGファイルの自己解凍機能を確認したときと同様、eval関数に渡される引数の中身が難読化される前のソースコードということになる。
難読化されたコードでは関数自体も難読化して表現されるため、どこからどこまでが引数なのかが非常にわかりにくい。

使えるテクニックとして、eval等の関数自体を別の関数に置き換えてから難読化されたコードを実行してみる。
先のJavaScriptコンソールに以下のようなコードを1行ずつ順に打ち込む。


eval("alert('本来はこのalert関数を呼び出すコードが難読化されています。')"); // evalを置き換える前の実行
eval = function(e) { console.log(e) };
eval("alert('本来はこのalert関数を呼び出すコードが難読化されています。')"); // evalを置き換えた後の実行


1回目の実行ではダイアログボックスが表示される。
eval関数を置き換えた後の2回目の実行では、コンソールログにeval関数の引数の内容が表示される。

この方法によって、難読化されていたとしても、eval関数にコードが渡される限りは元のソースコードを復元することができる。
実際に難読化されたコードでこの方法を試す場合は、eval関数を使っている行で、難読化されたJavaScriptコードをまるごとペーストすれば同様に復元できる。

eval関数の置き換えでうまく行かない場合は、次の方法を試すか、setTimeOutなどのその他のevalに相当する関数で同じことを試してみる。


Functionオブジェクトのコンストラクタに難読化されたコードを渡して、元のコードを実行する関数を生成するというものがある。
この手法で難読化されているかどうかは、難読化されたコードの末尾に関数呼び出しのための「()」が付いているかで判別できる。
今回の問題ではこちらのパターンで難読化されている。

この手法の難読化はevalのときよりも容易に解読可能。JavaScriptの関数オブジェクトはtoString()メソッドを備えている。
このメソッドは関数オブジェクトに対して実行されると、その関数の定義時の文字列を返す。以下のようなイメージ。


function sample() { alert('foo'); }

console.log(sample.toString());
/***********

function sample() { alert('foo'); }」
という文字列がコンソールログに表示される。
***********/


この方法で今回の問題の難読化されたコードを復元してみる。
画像ファイルを開いているFirefoxのコンソールで以下のコードを実行する。


copy(e) // =&gt; copy()は引数の中身をクリップボードにコピーするデバッグ用の関数

/*********
コピーした難読化されたコードの末尾の「()」を消し、代わりに「.toString()」を入力して実行する。
*********/
$=~[];$={___:++$,$$$$:(![]/* ??? 長いので省略 ??? */();\\&quot;+$.__$+$._$_+&quot;\&quot;&quot;)()).toString();


関数が表示される。
alert.givemeflagというメソッドを作成していることが確認できる。
コンソールに入力する。

bc. alert.givemeflag()


FLAG{javascript,amazing_language}というFLAGが表示される。

